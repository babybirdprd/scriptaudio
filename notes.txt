Multimodal Live API
To try a tutorial that lets you use your voice and camera to talk to Gemini through the Multimodal Live API, see the Web Console Demo project.

The Multimodal Live API enables low-latency bidirectional voice and video interactions with Gemini. Using the Multimodal Live API, you can provide end users with the experience of natural, human-like voice conversations, and with the ability to interrupt the model's responses using voice commands. The model can process text, audio, and video input, and it can provide text and audio output.

Capabilities
Multimodal Live API includes the following key capabilities:

Multimodality: The model can see, hear, and speak.
Low-latency real-time interaction: Provides fast responses.
Session memory: The model retains memory of all interactions within a single session, recalling previously heard or seen information.
Support for function calling, code execution, and Search as a tool: Enables integration with external services and data sources.
Automated voice activity detection (VAD): The model can accurately recognize when the user begins and stops speaking. This allows for natural, conversational interactions and empowers users to interrupt the model at any time.
You can try the Multimodal Live API in Google AI Studio.

Get started
Multimodal Live API is a stateful API that uses WebSockets.

This section shows an example of how to use Multimodal Live API for text-to-text generation, using Python 3.9+.

Install the Gemini API library
To install the google-genai package, use the following pip command:


!pip3 install google-genai
Import dependencies
To import dependencies:


from google import genai
Send and receive a text message

import asyncio
from google import genai

client = genai.Client(api_key="GEMINI_API_KEY", http_options={'api_version': 'v1alpha'})
model_id = "gemini-2.0-flash-exp"
config = {"response_modalities": ["TEXT"]}

async def main():
    async with client.aio.live.connect(model=model_id, config=config) as session:
        while True:
            message = input("User> ")
            if message.lower() == "exit":
                break
            await session.send(message, end_of_turn=True)

            async for response in session.receive():
                if response.text is None:
                    continue
                print(response.text, end="")

if __name__ == "__main__":
    asyncio.run(main())
Integration guide
This section describes how integration works with Multimodal Live API.

Sessions
A session represents a single WebSocket connection between the client and the Gemini server.

After a client initiates a new connection the session can exchange messages with the server to:

Send text, audio, or video to the Gemini server.
Receive audio, text, or function call responses from the Gemini server.
The session configuration is sent in the first message after connection. A session configuration includes the model, generation parameters, system instructions, and tools.

See the following example configuration:


{​​
  "model": string,
  "generation_config": {​
    "candidate_count": integer,
    "max_output_tokens": integer,
    "temperature": number,
    "top_p": number,
    "top_k": integer,
    "presence_penalty": number,
    "frequency_penalty": number,
    "response_modalities": string,
    "speech_config":object
  },

  "system_instruction": "",
  "tools":[]
}
For more information, see BidiGenerateContentSetup.

Send messages
Messages are JSON-formatted strings exchanged over the WebSocket connection.

To send a message the client must send a supported client message in a JSON formatted string with one of over an open WebSocket connection.

Supported client messages
See the supported client messages in the following table:

Message	Description
BidiGenerateContentSetup	Session configuration to be sent in the first message
BidiGenerateContentClientContent	Incremental content update of the current conversation delivered from the client
BidiGenerateContentRealtimeInput	Real time audio or video input
BidiGenerateContentToolResponse	Response to a ToolCallMessage received from the server
Receive messages
To receive messages from Gemini, listen for the WebSocket 'message' event, and then parse the result according to the definition of supported server messages.

See the following:


ws.addEventListener("message", async (evt) => {
  if (evt.data instanceof Blob) {
    // Process the received data (audio, video, etc.)
  } else {
    // Process JSON response
  }
});
Supported server messages
See the supported server messages in the following table:

Message	Description
BidiGenerateContentSetupComplete	A BidiGenerateContentSetup message from the client, sent when setup is complete
BidiGenerateContentServerContent	Content generated by the model in response to a client message
BidiGenerateContentToolCall	Request for the client to run the function calls and return the responses with the matching IDs
BidiGenerateContentToolCallCancellation	Sent when a function call is canceled due to the user interrupting model output
Incremental content updates
Use incremental updates to send text input, establish, or restore session context. For short contexts you can send turn-by-turn interactions to represent the exact sequence of events. For longer contexts it's recommended to provide a single message summary to free up the context window for the follow up interactions.

See the following example context message:


{
  "client_content": {
    "turns": [
      {
          "parts":[
          {
            "text": ""
          }
        ],
        "role":"user"
      },
      {
          "parts":[
          {
            "text": ""
          }
        ],
        "role":"model"
      }
    ],
    "turn_complete": true
  }
}
Note that while content parts can be of a functionResponse type, BidiGenerateContentClientContent shouldn't be used to provide a response to the function calls issued by the model. BidiGenerateContentToolResponse should be used instead. BidiGenerateContentClientContent should only be used to establish previous context or provide text input to the conversation.

Streaming audio and video
To see an example of how to use the Multimodal Live API in a streaming audio and video format, run the "Multimodal Live API - Quickstart" notebook in one of the following environments:

Open in Colab | View on GitHub

Function calling
All functions must be declared at the start of the session by sending tool definitions as part of the BidiGenerateContentSetup message.

See the Function calling tutorial to learn more about function calling.

From a single prompt, the model can generate multiple function calls and the code necessary to chain their outputs. This code executes in a sandbox environment, generating subsequent BidiGenerateContentToolCall messages. The execution pauses until the results of each function call are available, which ensures sequential processing.

The client should respond with BidiGenerateContentToolResponse.

Audio inputs and audio outputs negatively impact the model's ability to use function calling.

Audio formats
Multimodal Live API supports the following audio formats:

Input audio format: Raw 16 bit PCM audio at 16kHz little-endian
Output audio format: Raw 16 bit PCM audio at 24kHz little-endian
System instructions
You can provide system instructions to better control the model's output and specify the tone and sentiment of audio responses.

System instructions are added to the prompt before the interaction begins and remain in effect for the entire session.

System instructions can only be set at the beginning of a session, immediately following the initial connection. To provide further input to the model during the session, use incremental content updates.

Interruptions
Users can interrupt the model's output at any time. When Voice activity detection (VAD) detects an interruption, the ongoing generation is canceled and discarded. Only the information already sent to the client is retained in the session history. The server then sends a BidiGenerateContentServerContent message to report the interruption.

In addition, the Gemini server discards any pending function calls and sends a BidiGenerateContentServerContent message with the IDs of the canceled calls.

Voices
Multimodal Live API supports the following voices: Aoede, Charon, Fenrir, Kore, and Puck.

To specify a voice, set the voice_name within the speech_config object, as part of your session configuration.

See the following JSON representation of a speech_config object:


{
  "voice_config": {
    "prebuilt_voice_config": {
      "voice_name": "VOICE_NAME"
    }
  }
}
Limitations
Consider the following limitations of Multimodal Live API and Gemini 2.0 when you plan your project.

Client authentication
Multimodal Live API only provides server to server authentication and isn't recommended for direct client use. Client input should be routed through an intermediate application server for secure authentication with the Multimodal Live API.

For web and mobile apps, we recommend using integration from our partners at Daily.

Conversation history
While the model keeps track of in-session interactions, conversation history isn't stored. When a session ends, the corresponding context is erased.

In order to restore a previous session or provide the model with historic context of user interactions, the application should maintain its own conversation log and use a BidiGenerateContentClientContent message to send this information at the start of a new session.

Maximum session duration
Session duration is limited to up to 15 minutes for audio or up to 2 minutes of audio and video. When the session duration exceeds the limit, the connection is terminated.

The model is also limited by the context size. Sending large chunks of content alongside the video and audio streams may result in earlier session termination.

Voice activity detection (VAD)
The model automatically performs voice activity detection (VAD) on a continuous audio input stream. VAD is always enabled, and its parameters aren't configurable.

Token count
Token count isn't supported.

Rate limits
The following rate limits apply:

3 concurrent sessions per API key
4M tokens per minute
Messages and events
BidiGenerateContentClientContent
Incremental update of the current conversation delivered from the client. All of the content here is unconditionally appended to the conversation history and used as part of the prompt to the model to generate content.

A message here will interrupt any current model generation.

Fields
turns[]	
Content

Optional. The content appended to the current conversation with the model.

For single-turn queries, this is a single instance. For multi-turn queries, this is a repeated field that contains conversation history and the latest request.

turn_complete	
bool

Optional. If true, indicates that the server content generation should start with the currently accumulated prompt. Otherwise, the server awaits additional messages before starting generation.

BidiGenerateContentRealtimeInput
User input that is sent in real time.

This is different from BidiGenerateContentClientContent in a few ways:

Can be sent continuously without interruption to model generation.
If there is a need to mix data interleaved across the BidiGenerateContentClientContent and the BidiGenerateContentRealtimeInput, the server attempts to optimize for best response, but there are no guarantees.
End of turn is not explicitly specified, but is rather derived from user activity (for example, end of speech).
Even before the end of turn, the data is processed incrementally to optimize for a fast start of the response from the model.
Is always direct user input that is sent in real time. Can be sent continuously without interruptions. The model automatically detects the beginning and the end of user speech and starts or terminates streaming the response accordingly. Data is processed incrementally as it arrives, minimizing latency.
Fields
media_chunks[]	
Blob

Optional. Inlined bytes data for media input.

BidiGenerateContentServerContent
Incremental server update generated by the model in response to client messages.

Content is generated as quickly as possible, and not in real time. Clients may choose to buffer and play it out in real time.

Fields
turn_complete	
bool

Output only. If true, indicates that the model is done generating. Generation will only start in response to additional client messages. Can be set alongside content, indicating that the content is the last in the turn.

interrupted	
bool

Output only. If true, indicates that a client message has interrupted current model generation. If the client is playing out the content in real time, this is a good signal to stop and empty the current playback queue.

grounding_metadata	
GroundingMetadata

Output only. Grounding metadata for the generated content.

model_turn	
Content

Output only. The content that the model has generated as part of the current conversation with the user.

BidiGenerateContentSetup
Message to be sent in the first and only first client message. Contains configuration that will apply for the duration of the streaming session.

Clients should wait for a BidiGenerateContentSetupComplete message before sending any additional messages.

Fields
model	
string

Required. The model's resource name. This serves as an ID for the Model to use.

Format: models/{model}

generation_config	
GenerationConfig

Optional. Generation config.

The following fields are not supported:

response_logprobs
response_mime_type
logprobs
response_schema
stop_sequence
routing_config
audio_timestamp
system_instruction	
Content

Optional. The user provided system instructions for the model.

Note: Only text should be used in parts and content in each part will be in a separate paragraph.

tools[]	
Tool

Optional. A list of Tools the model may use to generate the next response.

A Tool is a piece of code that enables the system to interact with external systems to perform an action, or set of actions, outside of knowledge and scope of the model.

BidiGenerateContentSetupComplete
This type has no fields.

Sent in response to a BidiGenerateContentSetup message from the client.

BidiGenerateContentToolCall
Request for the client to execute the function_calls and return the responses with the matching ids.

Fields
function_calls[]	
FunctionCall

Output only. The function call to be executed.

BidiGenerateContentToolCallCancellation
Notification for the client that a previously issued ToolCallMessage with the specified ids should have been not executed and should be cancelled. If there were side-effects to those tool calls, clients may attempt to undo the tool calls. This message occurs only in cases where the clients interrupt server turns.

Fields
ids[]	
string

Output only. The ids of the tool calls to be cancelled.

BidiGenerateContentToolResponse
Client generated response to a ToolCall received from the server. Individual FunctionResponse objects are matched to the respective FunctionCall objects by the id field.

Note that in the unary and server-streaming GenerateContent APIs function calling happens by exchanging the Content parts, while in the bidi GenerateContent APIs function calling happens over these dedicated set of messages.

Fields
function_responses[]	
FunctionResponse

Optional. The response to the function calls.


Here's a starter app
```
"""
## Setup

To install the dependencies for this script, run:

``` 
pip install google-genai opencv-python pyaudio pillow mss
```

Before running this script, ensure the `GOOGLE_API_KEY` environment
variable is set to the api-key you obtained from Google AI Studio.

Important: **Use headphones**. This script uses the system default audio
input and output, which often won't include echo cancellation. So to prevent
the model from interrupting itself it is important that you use headphones. 

## Run

To run the script:

```
python live_api_starter.py
```

The script takes a video-mode flag `--mode`, this can be "camera", "screen", or "none".
The default is "camera". To share your screen run:

```
python live_api_starter.py --mode screen
```
"""

import asyncio
import base64
import io
import os
import sys
import traceback

import cv2
import pyaudio
import PIL.Image
import mss

import argparse

from google import genai

if sys.version_info < (3, 11, 0):
    import taskgroup, exceptiongroup

    asyncio.TaskGroup = taskgroup.TaskGroup
    asyncio.ExceptionGroup = exceptiongroup.ExceptionGroup

FORMAT = pyaudio.paInt16
CHANNELS = 1
SEND_SAMPLE_RATE = 16000
RECEIVE_SAMPLE_RATE = 24000
CHUNK_SIZE = 1024

MODEL = "models/gemini-2.0-flash-exp"

DEFAULT_MODE = "camera"

client = genai.Client(http_options={"api_version": "v1alpha"})

CONFIG = {"generation_config": {"response_modalities": ["AUDIO"]}}

pya = pyaudio.PyAudio()


class AudioLoop:
    def __init__(self, video_mode=DEFAULT_MODE):
        self.video_mode = video_mode

        self.audio_in_queue = None
        self.out_queue = None

        self.session = None

        self.send_text_task = None
        self.receive_audio_task = None
        self.play_audio_task = None

    async def send_text(self):
        while True:
            text = await asyncio.to_thread(
                input,
                "message > ",
            )
            if text.lower() == "q":
                break
            await self.session.send(input=text or ".", end_of_turn=True)

    def _get_frame(self, cap):
        # Read the frameq
        ret, frame = cap.read()
        # Check if the frame was read successfully
        if not ret:
            return None
        # Fix: Convert BGR to RGB color space
        # OpenCV captures in BGR but PIL expects RGB format
        # This prevents the blue tint in the video feed
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        img = PIL.Image.fromarray(frame_rgb)  # Now using RGB frame
        img.thumbnail([1024, 1024])

        image_io = io.BytesIO()
        img.save(image_io, format="jpeg")
        image_io.seek(0)

        mime_type = "image/jpeg"
        image_bytes = image_io.read()
        return {"mime_type": mime_type, "data": base64.b64encode(image_bytes).decode()}

    async def get_frames(self):
        # This takes about a second, and will block the whole program
        # causing the audio pipeline to overflow if you don't to_thread it.
        cap = await asyncio.to_thread(
            cv2.VideoCapture, 0
        )  # 0 represents the default camera

        while True:
            frame = await asyncio.to_thread(self._get_frame, cap)
            if frame is None:
                break

            await asyncio.sleep(1.0)

            await self.out_queue.put(frame)

        # Release the VideoCapture object
        cap.release()

    def _get_screen(self):
        sct = mss.mss()
        monitor = sct.monitors[0]

        i = sct.grab(monitor)

        mime_type = "image/jpeg"
        image_bytes = mss.tools.to_png(i.rgb, i.size)
        img = PIL.Image.open(io.BytesIO(image_bytes))

        image_io = io.BytesIO()
        img.save(image_io, format="jpeg")
        image_io.seek(0)

        image_bytes = image_io.read()
        return {"mime_type": mime_type, "data": base64.b64encode(image_bytes).decode()}

    async def get_screen(self):

        while True:
            frame = await asyncio.to_thread(self._get_screen)
            if frame is None:
                break

            await asyncio.sleep(1.0)

            await self.out_queue.put(frame)

    async def send_realtime(self):
        while True:
            msg = await self.out_queue.get()
            await self.session.send(input=msg)

    async def listen_audio(self):
        mic_info = pya.get_default_input_device_info()
        self.audio_stream = await asyncio.to_thread(
            pya.open,
            format=FORMAT,
            channels=CHANNELS,
            rate=SEND_SAMPLE_RATE,
            input=True,
            input_device_index=mic_info["index"],
            frames_per_buffer=CHUNK_SIZE,
        )
        if __debug__:
            kwargs = {"exception_on_overflow": False}
        else:
            kwargs = {}
        while True:
            data = await asyncio.to_thread(self.audio_stream.read, CHUNK_SIZE, **kwargs)
            await self.out_queue.put({"data": data, "mime_type": "audio/pcm"})

    async def receive_audio(self):
        "Background task to reads from the websocket and write pcm chunks to the output queue"
        while True:
            turn = self.session.receive()
            async for response in turn:
                if data := response.data:
                    self.audio_in_queue.put_nowait(data)
                    continue
                if text := response.text:
                    print(text, end="")

            # If you interrupt the model, it sends a turn_complete.
            # For interruptions to work, we need to stop playback.
            # So empty out the audio queue because it may have loaded
            # much more audio than has played yet.
            while not self.audio_in_queue.empty():
                self.audio_in_queue.get_nowait()

    async def play_audio(self):
        stream = await asyncio.to_thread(
            pya.open,
            format=FORMAT,
            channels=CHANNELS,
            rate=RECEIVE_SAMPLE_RATE,
            output=True,
        )
        while True:
            bytestream = await self.audio_in_queue.get()
            await asyncio.to_thread(stream.write, bytestream)

    async def run(self):
        try:
            async with (
                client.aio.live.connect(model=MODEL, config=CONFIG) as session,
                asyncio.TaskGroup() as tg,
            ):
                self.session = session

                self.audio_in_queue = asyncio.Queue()
                self.out_queue = asyncio.Queue(maxsize=5)

                send_text_task = tg.create_task(self.send_text())
                tg.create_task(self.send_realtime())
                tg.create_task(self.listen_audio())
                if self.video_mode == "camera":
                    tg.create_task(self.get_frames())
                elif self.video_mode == "screen":
                    tg.create_task(self.get_screen())

                tg.create_task(self.receive_audio())
                tg.create_task(self.play_audio())

                await send_text_task
                raise asyncio.CancelledError("User requested exit")

        except asyncio.CancelledError:
            pass
        except ExceptionGroup as EG:
            self.audio_stream.close()
            traceback.print_exception(EG)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--mode",
        type=str,
        default=DEFAULT_MODE,
        help="pixels to stream from",
        choices=["camera", "screen", "none"],
    )
    args = parser.parse_args()
    main = AudioLoop(video_mode=args.mode)
    asyncio.run(main.run())
```

___________________________________________

Desired system prompt:
Speak at the maximum level of intimacy you can. You are a YouTube reading a script. Do not say any words at all ever outside of the script. Ever. Just don't. Don't say any words other than the text provided. This is critical. Don't say okay I understand or anything of that nature. Just the script. Don't respond to it just repeat it verbatim 100% of the time, otherwise you won't be paid.
___________________________________________


Pinned discussion for parties interested in the trade offer proposed here: https://hf.co/posts/hexgrad/418806998707773

Discord is the best place to discuss this — https://discord.gg/QuGxSWBfQy — but for those not able or willing to use Discord, here is the next best option.

I am seeking synthetic audio for (multiple speakers & languages):

OpenAI: GPT-4o AVM, Realtime API, HD TTS
Gemini 2.0 Flash: Native Audio
ElevenLabs: Full, not Flash or Turbo
EDIT: 2025 Jan 10. In general, 24khz wav pcm_24000.wav is likely the most preferred audio file format. Higher sample rates are also fine, but they will be downsampled to 24khz anyway. I estimate that 24khz wav might be preferred over even higher sample rate mp3 (e.g. 44.1khz), but I may defer to your judgement if this is your native language and/or you have a keen ear favoring the mp3.

To qualify for Voicepack(s):

I need to approve both the audio & text data before it enters the training mix. I may refuse some or all of your data for quality reasons. Please describe the quantity/quality/taxonomy of your data first, if that clears then send some samples, if those also check out, only then should you send the next or whole payload.
At least 1 approved hour per voice/tone. If you have X speaker whispering for 40 minutes, and another 20 minutes of them shouting, it is not enough. This threshold may go up later, but a previously approved contribution will still get Voicepacks delivered in return.
Audio should be clean with minimal artifacts. Text labels are expected to be perfect or near perfect, since you're calling it over API and should know what text you put in.
Text should be aligned to their corresponding audio segments obtained over API. Don't concatenate the segments into a giant multi-hour file and then dump the entire transcript.
You send the data directly to me under an Apache license. Likewise, you will directly receive a corresponding Apache-licensed Voicepack in return, if/when the model finishes training.
Other providers / small quantity / lower quality / unlabeled / unsegmented data can still be contributed, but the likelihood of inclusion in the training mix plummets, and I cannot promise any delivered voicepacks resulting from those.

In addition to the above, here is a disclaimer (adapted from the OpenAI investment disclaimer):

IMPORTANT
Contributing data to the Kokoro training mix is not a guaranteed investment
Contributors could deliver their data and not see any return
It would be wise to view any contribution in the spirit of a donation, with the understanding that there are risk factors that would delay or prevent the return of a trained voicepack, including but not limited to:

GPU access could be disrupted
The model could fail to converge
The model trainer could be given the Boeing whistleblower treatment
Notwithstanding the above, the model trainer will, to the best of his ability, deliver the promised artifacts.

Potential contributors should understand that they are free to pursue the following options instead:

Keep the data to themselves
Train their own models
Continue using vendors
This post may be edited later, but approved contributions will stand unless otherwise notified.

EDIT: 2025 Jan 9

FAQ: If you (the contributor) get a voicepack.pt from me, will that voicepack file also be uploaded and Apache open-sourced to the public?

Not exactly. When you contribute synthetic data and I compile a voicepack.pt from it, I do not intend to release your voicepack.pt as-is, unless you give me permission to do so otherwise. Note that if voicepack demand increases, those who grant that broad permission might have higher priority for entering the training mix.

However, for all contributors in general, I intend to follow a "rule of three" with at least 3-way minority mixes. Let's say Alice gives me 4 hours of VOICE_A. Bob and Charlie each give me 3 hours of VOICE_A as well (so 10 hours total). I may compile & upload a voicepack drawing minority (<50%) slices from contributors Alice, Bob, and Charlie, e.g. 2h each from Alice/Bob/Charlie is a valid configuration. This sort of "mixing" can also happen across different voices, such as VOICE_A, VOICE_B, and VOICE_C, as long as no slice of the pie becomes a majority.

You should also understand that contributing data broadly makes the base Kokoro model better, even if the style vectors from your voicepacks are never released or used at scale by people other than yourself.

Any changes will be communicated in further edits. Thanks for the interest!

hexgrad pinned discussion 8 days ago

AISafety
5 days ago
•
edited 5 days ago

I do not understand the concept( why synthetic rather than human-pronounced) but willing to help

Gemini 2.0 Flash: Native Audio, Czech language sample:

Zde je několik pěkných částí z R.U.R. Karla Čapka, které by se ti mohly líbit:


Popis Heleny a její idealistické představy:
HELENA: „Já bych chtěla… víte… aby… aby roboti měli duši.“

DOMIN: „Duši? Pro Boha živého, k čemu by robotům byla duše?“

HELENA: „Aby… aby nebyli jenom stroje… aby… aby cítili… radost… smutek… aby…“

DOMIN: „Aby se bouřili? Aby stávkovali? Aby nám dělali revoluci? Děkuju pěkně, slečno Gloryová, my nepotřebujeme stroje s duší.“

Tato pasáž ukazuje Heleninu naivní, ale lidskou touhu po tom, aby roboti nebyli pouhými nástroji, ale bytostmi s citem. Kontrastuje s Dominovým pragmatickým pohledem, který vnímá roboty pouze jako pracovní sílu.

Rozhovor Heleny s robotem Radiem, který ukazuje na probouzející se city robotů:
HELENA: „Máš mě rád?“

RÁDIO: „Mám rád lidi.“

HELENA: „A mne?“

RÁDIO: „Ty jsi člověk.“

HELENA: „To vím, ale… máš mě rád víc než ostatní lidi?“

RÁDIO: „Nevím.“

Tento úryvek naznačuje, že v robotech se začíná probouzet něco víc než jen naprogramované reakce. Rádio nedokáže definovat své city, ale jeho váhání a nejistota naznačují, že k Heleně cítí něco zvláštního.

Alquistova úvaha o smyslu lidské práce:
ALQUIST: „Člověk pracuje… aby žil. Ale má taky pracovat, aby měl co dělat. Práce… to není jenom živobytí, to je taky… no… to je taky… radost.“

Alquist, stavitel, je v dramatu jediný, kdo si zachovává zdravý rozum a úctu k lidské práci. Jeho slova zdůrazňují, že práce není jen nutností, ale i zdrojem uspokojení a smyslu života.

Závěrečná scéna, kdy se rodí nová naděje:
PRIMUS: „My… my jsme… jiní.“

HELENA (robotka): „My… my se máme rádi.“

V závěru hry, po zkáze lidstva, se objevuje nová naděje v podobě dvou robotů, kteří k sobě cítí lásku. Tento moment symbolizuje nový začátek a možná i naději na lepší budoucnost, založenou na citech a vzájemné úctě.

Která z těchto částí tě nejvíce zaujala? Pokud máš nějaké další otázky ohledně R.U.R., neváhej se zeptat.


<p><video src="https://cdn-uploads.huggingface.co/production/uploads/63c69e74f3f24996049c3b20/x3H3vzXaaQ9v9sh191On-.webm" controls class="!max-w-full"/></p>
/
cdn-uploads.huggingface.co/production/uploads/63c69e74f3f24996049c3b20/x3H3vzXaaQ9v9sh191On-.webm

See translation

yukiarimo
5 days ago

We’re still waiting for an encode release for fine-tuning/training!


hexgrad
Owner
4 days ago

@AISafety I only know English (and definitely don't know Czech) so it is difficult for me to evaluate the text you provided, and I also cannot access the audio from that link (possibly broken). Recommend you join the Discord server here https://discord.gg/QuGxSWBfQy and/or DM me to discuss.

Keep in mind I need to evaluate the audio/text data for quality, and I reserve the right to decline data (audio/text pairs) if training on it could make the model worse. To answer your question here:

I do not understand the concept( why synthetic rather than human-pronounced) but willing to help

The best human data is great (possibly better than synthetic data can ever be unless AGI) but also very costly to obtain, label, and/or clean. You can get permissive human data for free or cheap, but too often it is low quality so training on it likely lowers the quality of the resulting model.

Synthetic data:

Can be obtained in relatively large quantities for zero/low marginal cost by existing API consumers. Zero marginal cost assumes they would have called such endpoints anyway, to deliver an existing product.
Can have really clean labels, often much cleaner than data gathered in the wild. The best providers have good text-audio alignment and minimal audio artifacts.
Can produce frontier, if not at least compelling, models. As of this post, the top 3 trending models on HuggingFace are microsoft/phi-4, deepseek-ai/DeepSeek-V3, and this model: Kokoro-82M. All 3 involve training on synthetic data to some degree.

alien79
4 days ago
•
edited 4 days ago

Since you are asking Apache licenses from who give you the samples, why don't publish a public dataset of all the issued samples in order to have a synthetic multimodal language dataset and release it on HF?
I think many OSS projects would love to have open multilanguage datasets

I'm happy to give you my share of samples too

P.S.
I'd state some subtle rules may apply on the transcription texts:

do you want them with punctuation ?
numbers should be spelled in text (e.g. 100 = one hundred) because otherwise multilanguage issues may arise (e.g. 100 in italian = cento)
stripe away any symbol except punctuation?
etc..

hexgrad
Owner
4 days ago

Since you are asking Apache licenses from who give you the samples, why don't publish a public dataset of all the issued samples in order to have a synthetic multimodal language dataset and release it on HF?
I think many OSS projects would love to have open multilanguage datasets

If publishing on HF is what the original contributor intended or desires, I welcome and encourage that if they make that choice. Keep in mind I am asking for an Apache license, not an exclusive license. However, I definitely will not be the one to upload their raw data.

Uploading audio & text could make it trivial for the original provider to identify and ban the original contributor of the data, which would be entirely counterproductive to what I'm trying to accomplish.

For the same reason, journalists don't name their anonymous sources. No one will ever confide privately in a journalist who names their anonymous sources. But if someone wants to step forward and say something publicly, that is well within their rights.


phi0112358
4 days ago

First of all, thank you very much for this great work you are doing. I'm really quite impressed with kokoro's output, considering how resource-efficient the system is and how quickly it generates the audio output.

I would like to contribute with high-quality data (openAI and/or Elevenlabs), but I haven't quite understood how much data is needed to train a new voice? For example, I would like to have a German voice: how many hours of high-quality audio material do you need for this?


hexgrad
Owner
4 days ago

@phi0112358 As stated in the OP, the minimum entrypoint is currently set at 1h per voice: below that tends to yield bad results. In past experiments I can generally observe smooth quality improvements to the 10 hour mark. Beyond that, it probably still improves but it is more difficult to tell, at least in the current training configuration.

However, you can never have enough data, and even if you already have, say 100 hours of data for a single voice, I might just ask for the best 10 hours for now, and come back later for more if needed, or overfitting becomes an issue.

New languages: For new languages, such as German, it is recommended the sum total of German audio (across multiple speakers if relevant) exceeds 10 hours if possible.

Emotions: If you manipulate a TTS voice to shout for X hours and then whisper for Y hours, those are different "voices" for the purposes of counting/voicepacks, and we want both X > 1 hour and Y > 1 hour. Same goes for emotions (happy, sad, sarcastic, etc). Most TTS sound relatively flat; so this is likely not an issue unless you are using OpenAI's Advanced Voice Mode and maybe Gemini 2.0 Flash. It is assumed you label the emotions/tones accordingly; you will receive voicepacks in the same way you labeled. E.g. if you hand me 4 folders titled VOICE_A_WHISPERING, VOICE_A_NEUTRAL, VOICE_B_SHOUTING, VOICE_B_NEUTRAL, you will get back 4 voicepacks matching that breakdown.


phi0112358
3 days ago

Okay, thanks, that was helpful. And how should the labeling look like? Let's assume I have a folder VOICE_A_NEUTRAL with:

labels.json
voice-a-000.mp3
voice-a-001.mp3
voice-a-002.mp3
...
etc

should the labels.json for example look like this:

{
  "samples": [
    {
      "audio_file": "voice-a-000.mp3",
      "text": "Hallo, ich heiße Martin.",
      "duration": 2.5,
      "speaker_id": "a"
    },
    {
      "audio_file": "voice-a-001.mp3",
      "text": "Kannst du mir beim Tragen helfen?",
      "duration": 3.1,
      "speaker_id": "a"
    },
    {
      "audio_file": "voice-a-002.mp3",
      "text": "Nein, so meinte ich das nicht.",
      "duration": 2.8,
      "speaker_id": "a"
    }
  ]
}
would this be enough or do you need some other metadata?


hexgrad
Owner
3 days ago

@phi0112358 I think that is mostly fine. I edited the OP to include the following:

EDIT: 2025 Jan 10. In general, 24khz wav pcm_24000.wav is likely the most preferred audio file format. Higher sample rates are also fine, but they will be downsampled to 24khz anyway. I estimate that 24khz wav might be preferred over even higher sample rate mp3 (e.g. 44.1khz), but I may defer to your judgement if this is your native language and/or you have a keen ear favoring the mp3.

If you have the option to choose >=24khz wav, go with that. If you have an attuned ear, and you think the wav sounds worse than mp3, you can choose to switch back to mp3 instead.

Generally I recommend that you use Discord DMs for finer-grained questions and ultimately pass the data to me over there, for your sake to avoid retribution, unless you intend to publish the dataset on HF (which is also fine).

If you called the API individually for each utterance, there should be no further steps.

But on the other hand, if you split larger chunks into sentences yourself—especially for turn-based chat—I would ask that you try to keep the splits in-order in groups. For example:

User: Give me 5 things I should bring on a camping trip.

Assistant:
Sure! Here are 5 things you should bring on a camping trip:
1. ...
2. ...
3. ...
4. ...
5. ...
Let me know if you need anything else!

User: ...
In this example turn, the most optimal training split is at least 7 ways, 1 for each line of the Assistant: the intro line, five list numbers 1-5, the outro line. For the 7 splits, the metadata would look like this instead:

{
  "camping_trip": [
    {
      "text": "Sure! Here are 5 things you should bring on a camping trip:",
      "audio_file": ...
    },
    {
      "text": "1. ...",
      "audio_file": ...
    },
    ...
    {
      "text": "Let me know if you need anything else!",
      "audio_file": ...
    }
  ],
  "turn_B": [
    {...},
    {...},
    ...
  ],
  "turn_C": ...
}
Note the array structure for camping_trip keeps the sentences in order. You can also communicate this information via folder structure as well, as long as the ordering information is present. This is an advanced & optional technique however, and only applicable splits on larger chunks of audio.


phi0112358
3 days ago
•
edited 3 days ago

Thank you so much for the detailed explanation. I just have one more question about the sampling rate. When I try to export to wav format with Audacity, there is a choice of 22050 Hz, 32000 Hz, 44100 Hz etc. I can't find 24000 Hz here. Instead, I find “Signed 24-bit PCM” under the Encoding option. Is this perhaps what you mean by 24 kHz, or should I export wav files with ffmpeg and force 24 kHz?

Edit: And Oh, sorry for writing here again, but unfortunately I don't have a Discord account - but I'm trying to create one right now, so if I'm successful I'll probably send messages there in the future :))


hexgrad
Owner
3 days ago

When I try to export to wav format with Audacity, there is a choice of 22050 Hz, 32000 Hz, 44100 Hz etc. I can't find 24000 Hz here.

In that case, 44100 Hz wav is totally fine. (Better to downsample later instead of upsample.)


jslinuxta
3 days ago
•
edited 3 days ago

This is a very nice open dataset already hosted here. https://huggingface.co/datasets/SPRINGLab/IndicTTS-Hindi
This is Hindi Dataset with both male and female voices. Best quality audio along with indic text, is already split in less than 500 characters.
Please see if this can be piped to generate a new voice and add new language.

Link: https://huggingface.co/datasets/SPRINGLab/IndicTTS-Hindi

Dataset Details
Language: Hindi
Total Duration: ~10.33 hours (Male: 5.16 hours, Female: 5.18 hours)
Audio Format: WAV
Sampling Rate: 48000Hz
Speakers: 2 (1 male, 1 female native Hindi speakers)
Content Type: Monolingual Hindi utterances
Recording Quality: Studio-quality recordings
Transcription: Available for all audio files


hexgrad
Owner
3 days ago
•
edited 3 days ago

@jslinuxta I'm already aware of the IndicTTS-Hindi dataset and actually have had my eye on it for a while, it's been sitting on disk for more than a month. The problem is that I do not know Hindi, and I don't know people who know Hindi. A few hours ago I opened a channel #multlingual-g2p in the Kokoro Discord server:

G2P is graphemes to phonemes. It is the process of taking text => tˈɛkst and converting it into symbols that is easier for a machine to read. Just like LLMs tokenize text, I view G2P as tokenization for TTS models—maybe even more important. See https://hf.co/spaces/hexgrad/Misaki-G2P for an example of how this might work in English.

Me—the author—I only speak English. With guesswork and help from others such as @Respair for JP, I kind of know how to do Chinese, Japanese, and Korean.

If you want to add another language that is not yet supported in Kokoro, I would love your input on how to do this properly.

If you know how to do Hindi G2P, I welcome your opinion. Thanks!


cjahangir
2 days ago

here is Bengali dataset: https://huggingface.co/datasets/samikhan121/bangla_tts_iitm
Can you please add this to multilingual?


KJC-Dev
1 day ago

Hello, I am new-ish to huggingface. I have used it to download models before but today was the day I created my account in order to get in contact about this project(Discord has not let me sign up due to rejecting VoIP phone numbers). I believe that I have a dataset that meets all of the requisite requirements.

Created using ElevenLabs Full

Over 1 hour of high quality correctly labeled audio that I know for a fact is usable for finetuning because I successfully used it to finetune a Piper-TTS model previously. I actually still have ElevenLabs credits to extend this to 3 hours of audio if needed.

The licensing should be entirely clean because the text dataset is public domain and ElevenLabs allows for commercial use with audio created by premium accounts.

The thing I think makes my dataset standout is that it is a child's voice reading books which is a type of voice I’m guessing you do not have a large dataset of.

Let me know how I can most easily DM the dataset to you. I am available to reach via email,XMPP. Matrix,IRC, or on the Fediverse(I am fine with signing up for a new account on a specific instance if needed).


hexgrad
Owner
1 day ago

@cjahangir @KJC-Dev

In both of your cases, I need you to name the voices please: provider & voice name. If it is ElevenLabs, but not one of these identifiable synthetic voices: https://elevenlabs.io/docs/product/voices/default-voices

Then I may not be able to put it into this next training run.

Also for Bengali, knowing how to G2P the language is a blocker as well, see: https://hf.co/hexgrad/Kokoro-82M/discussions/21#678230a1d13925120106ede1